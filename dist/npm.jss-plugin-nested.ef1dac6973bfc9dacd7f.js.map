{"version":3,"sources":["webpack:///./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js"],"names":["separatorRegExp","parentRegExp","refRegExp","getReplaceRef","container","sheet","match","key","rule","getRule","selector","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","i","length","parent","j","nested","indexOf","replace","getOptions","prevOptions","index","nestingLevel","options","undefined","name","onProcessStyle","style","type","replaceRef","styleRule","prop","isNested","isNestedConditional","addRule"],"mappings":"4FAAA,gBAGIA,EAAkB,WAClBC,EAAe,KACfC,EAAY,cAyGD,IAjGf,WAEE,SAASC,EAAcC,EAAWC,GAChC,OAAO,SAAUC,EAAOC,GACtB,IAAIC,EAAOJ,EAAUK,QAAQF,IAAQF,GAASA,EAAMI,QAAQF,GAE5D,OAAIC,GACFA,EAAOA,GACKE,SAIPH,GAIX,SAASI,EAAkBC,EAAYC,GAKrC,IAJA,IAAIC,EAAkBD,EAAWE,MAAMf,GACnCgB,EAAkBJ,EAAWG,MAAMf,GACnCiB,EAAS,GAEJC,EAAI,EAAGA,EAAIJ,EAAgBK,OAAQD,IAG1C,IAFA,IAAIE,EAASN,EAAgBI,GAEpBG,EAAI,EAAGA,EAAIL,EAAgBG,OAAQE,IAAK,CAC/C,IAAIC,EAASN,EAAgBK,GACzBJ,IAAQA,GAAU,MAEtBA,IAAmC,IAAzBK,EAAOC,QAAQ,KAAcD,EAAOE,QAAQvB,EAAcmB,GAAUA,EAAS,IAAME,EAIjG,OAAOL,EAGT,SAASQ,EAAWjB,EAAMJ,EAAWsB,GAEnC,GAAIA,EAAa,OAAO,YAAS,GAAIA,EAAa,CAChDC,MAAOD,EAAYC,MAAQ,IAE7B,IAAIC,EAAepB,EAAKqB,QAAQD,aAChCA,OAAgCE,IAAjBF,EAA6B,EAAIA,EAAe,EAE/D,IAAIC,EAAU,YAAS,GAAIrB,EAAKqB,QAAS,CACvCD,aAAcA,EACdD,MAAOvB,EAAUmB,QAAQf,GAAQ,IAKnC,cADOqB,EAAQE,KACRF,EA0CT,MAAO,CACLG,eAxCF,SAAwBC,EAAOzB,EAAMH,GACnC,GAAkB,UAAdG,EAAK0B,KAAkB,OAAOD,EAClC,IAEIJ,EACAM,EAHAC,EAAY5B,EACZJ,EAAYgC,EAAUP,QAAQT,OAIlC,IAAK,IAAIiB,KAAQJ,EAAO,CACtB,IAAIK,GAAkC,IAAvBD,EAAKd,QAAQ,KACxBgB,EAAkC,MAAZF,EAAK,GAC/B,GAAKC,GAAaC,EAAlB,CAGA,GAFAV,EAAUJ,EAAWW,EAAWhC,EAAWyB,GAEvCS,EAAU,CACZ,IAAI5B,EAAWC,EAAkB0B,EAAMD,EAAU1B,UAG5CyB,IAAYA,EAAahC,EAAcC,EAAWC,IAEvDK,EAAWA,EAASc,QAAQtB,EAAWiC,GACvC/B,EAAUoC,QAAQ9B,EAAUuB,EAAMI,GAAO,YAAS,GAAIR,EAAS,CAC7DnB,SAAUA,UAEH6B,GAETnC,EAAUoC,QAAQH,EAAM,GAAIR,GAG3BW,QAAQJ,EAAU7B,IAAK0B,EAAMI,GAAO,CACnC3B,SAAU0B,EAAU1B,kBAIjBuB,EAAMI,IAGf,OAAOJ","file":"npm.jss-plugin-nested.ef1dac6973bfc9dacd7f.js","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport warning from 'tiny-warning';\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        rule = rule;\n        return rule.selector;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options) // Flow expects more options but they aren't required\n        // And flow doesn't know this will always be a StyleRule which has the addRule method\n        // $FlowFixMe\n        .addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\nexport default jssNested;\n"],"sourceRoot":""}